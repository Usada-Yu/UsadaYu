/********************************************************************************************
 * 1. 关于ARM
 * @ref https://zhuanlan.zhihu.com/p/388683540
 * 
 * ARM汇编的格式一般为：
 * <opcode> {<cond>} {S} <Rd>,<Rn>,<shifter_operand>
 * Example: sub sp, sp, #32
 * 几个比较重要的部分如下：
 * 1. opcode：表示汇编指令，如样例中的sub指令，表示减法
 * 2. Rd：表示指令操作的目的寄存器，如样例中的sp寄存器
 * 3. Rn：表示指令的第一源操作数，如样例中的sp寄存器
 * 4. shifter_operand：表示数据处理指令，如样例中的#32，表示立即寻址
 * 综上，上述样例翻译成伪代码就是：sp = sp - 32 (Rd = Rn - 32)
********************************************************************************************/

/********************************************************************************************
 * ARM64架构下，CPU提供了33个寄存器
 * 前31个(0~30)是通用寄存器；最后2个(31, 32)是专用寄存器(sp寄存器, pc寄存器)
 * 
 * 1. 汇编的寄存器名称和数字索引通常不区分大小写。
 * 如SP寄存器和sp寄存器一般会被视为相同的寄存器；X29寄存器和x29寄存器一般也会被视为相同的寄存器。
 * 但这不是绝对的，具体取决于汇编语言本身和它的编译器。编写前查阅相关手册为最佳
 * 
 * 2. 通用寄存器有两种访问方式：
 * (1) 将通用寄存器作为32bit寄存器时，使用w0~w30来引用(此时数据保存在寄存器的低32位)
 * (2) 将通用寄存器作为64bit寄存器时，使用x0~x30来引用
 * 
 * 3. 第31个专用寄存器的访问方式有4中：
 * (1) 将其作为32bit栈帧指针寄存器(stack pointer)时，使用WSP来引用
 * (2) 将其作为62bit栈帧指针寄存器(stack pointer)时，使用SP来引用
 * (3) 将其作为32bit零寄存器(zero register)时，使用WZR来引用
 * (4) 将其作为62bit零寄存器(zero register)时，使用ZR来引用
 * 
 * 4. 第32个专用寄存器是不能被汇编代码访问的，无论是用x32数字索引还是pc寄存器名称，都不能访问。
 * 这个寄存器实际上是给CPU执行汇编指令时使用的，它永远记录着当前CPU正在执行哪一句指令的地址
 * 
 * 5. 访问寄存时需注意：
 * (1) 一些通用寄存器除了数字索引，也是有名称的，如FP(x29)、LR(x30)等。
 *     但这些寄存器不可以像SP寄存器一样直接用名称访问，必须使用数字索引访问
********************************************************************************************/

/********************************************************************************************
 * 关于33个寄存器
 * 
 * 寄存器           说明
 * X0               用来保存返回值(或传参)
 * X1 ~ X7          用来保存函数的传参
 * X8               也可以用来保存返回值
 * X9 ~ X28         一般寄存器，无特殊用途
 * x29(FP)          用来保存栈底地址
 * X30(LR)          用来保存返回地址
 * X31(SP)          用来保存栈顶地址
 * X31(ZR)          零寄存器，恒为0
 * X32(PC)          用来保存当前执行的指令的地址
********************************************************************************************/
